#+title: finding the optimal svalboard layout with gurobi
 #+PROPERTY: header-args:python :results output :async t drawer :python "nix-shell --run python" :tangle :session project :timer-show no :exports both

#+begin_src python
import gurobipy as gp
import pandas as pd
import numpy as np
from dataclasses import dataclass
from typing import List
#+end_src

#+RESULTS:

* scratch: toy bipartite graph matching (weight per letter, cost per key)

#+begin_src python
letter_frequencies = pd.read_csv(
    './letter-frequencies.csv',
    header=None,
    names=['letter', 'texts', 'dictionaries'],
    index_col='letter'
)
print(letter_frequencies)
#+end_src

#+RESULTS:
#+begin_example
| letter | texts | dictionaries |
|--------+-------+--------------|
| A      |   8.2 |          7.8 |
| B      |   1.5 |          2.0 |
| C      |   2.8 |          4.0 |
| D      |   4.3 |          3.8 |
| E      |  12.7 |         11.0 |
| F      |   2.2 |          1.4 |
| G      |   2.0 |          3.0 |
| H      |   6.1 |          2.3 |
| I      |   7.0 |          8.6 |
| J      |  0.15 |         0.21 |
| K      |  0.77 |         0.97 |
| L      |   4.0 |          5.3 |
| M      |   2.4 |          2.7 |
| N      |   6.7 |          7.2 |
| O      |   7.5 |          6.1 |
| P      |   1.9 |          2.8 |
| Q      | 0.095 |         0.19 |
| R      |   6.0 |          7.3 |
| S      |   6.3 |          8.7 |
| T      |   9.1 |          6.7 |
#+end_example

#+begin_src python
key_costs = [*map(abs, np.random.randn(26))] # TODO
print(key_costs)
#+end_src

#+RESULTS:
: [0.8503275992394355, 1.6167658562189116, 0.2830689248704767, 1.0155322703229546, 0.1600824116332789, 0.021097920847273247, 0.7282346632832309, 0.4782015163011322, 2.5741366586781993, 0.019397697910186536, 1.704405556848405, 2.0705192360819047, 0.1751303843351309, 0.5611328309187863, 0.1573387380844285, 0.8338025974809553, 0.17955764685577943, 0.6038608127068892, 0.2530755441386779, 1.1285021797871388, 0.0559717233093392, 0.3834140816599339, 0.2687149839553213, 0.43667658900129713, 0.3428545630754759, 0.6571548638725636]

26 letters

#+begin_src python
letters = [*letter_frequencies.index]
print(letters)
assert(len(letters) == 26)
#+end_src

#+RESULTS:
: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']

26 keys, labeled by index (for now!)

#+begin_src python
keys = [*range(26)]
#+end_src

#+RESULTS:

#+begin_src python
m = gp.Model()
keys_to_letters = m.addVars(letters, keys, vtype=gp.GRB.BINARY)
# m.addConstr(sum(*keys_to_letters) = 26)
#+end_src

#+RESULTS:

Can we look up the key assignments per letter?

#+begin_src python
print([keys_to_letters['A', key] for key in keys])
#+end_src

#+RESULTS:
: [<gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>, <gurobi.Var *Awaiting Model Update*>]

#+begin_src python
m.addConstrs(
    (
        sum(keys_to_letters[letter, key] for key in keys) == 1
        for letter in letters
    ),
    name='each letter assigned once'
)
#+end_src

#+RESULTS:

#+begin_src python
m.addConstrs(
    (
        sum(keys_to_letters[letter, key] for letter in letters) == 1
        for key in keys
    ),
    name='each key assigned once'
)
#+end_src

#+RESULTS:


*** OBJECTIVE FUNCTION BABEYY

#+begin_src python
def key_letter_weight(letter, key):
    return letter_frequencies.loc[[letter]].texts.iloc[0] * key_costs[key]
#+END_SRC

#+RESULTS:

#+begin_src python
print(key_letter_weight('A', 10))
#+END_SRC

#+RESULTS:
: 1.964127701329608

#+begin_src python
m.setObjective(
    sum(
        key_letter_weight(letter, key) * keys_to_letters[letter, key]
        for letter in letters
        for key in keys
    ),
    sense=gp.GRB.MINIMIZE
)
#+end_src

#+RESULTS:

#+begin_src python
m.optimize()
#+END_SRC

#+RESULTS:
#+begin_example
Gurobi Optimizer version 11.0.3 build v11.0.3rc0 (linux64 - "NixOS 25.05 (Warbler)")
CPU model: AMD Ryzen 7 7840U w/ Radeon  780M Graphics, instruction set [SSE2\AVX\AVX2\AVX512]
Thread count: 8 physical cores, 16 logical processors, using up to 16 threads
Optimize a model with 52 rows, 676 columns and 1352 nonzeros
Model fingerprint: 0xbda6a150
Variable types: 0 continuous, 676 integer (676 binary)
Coefficient statistics:
Matrix range     [1e+00, 1e+00]
Objective range  [2e-03, 2e+01]
Bounds range     [1e+00, 1e+00]
RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 79.9210606
Presolve time: 0.00s
Presolved: 52 rows, 676 columns, 1352 nonzeros
Variable types: 0 continuous, 676 integer (676 binary)
Root relaxation: objective 4.181806e+01, 210 iterations, 0.00 seconds (0.00 work units)
Nodes    \    Current Node    \     Objective Bounds      \     Work
Expl Unexpl \  Obj  Depth IntInf \ Incumbent    BestBd   Gap \ It/Node Time
,*    0     0               0      41.8180586   41.81806  0.00%     -    0s
Explored 1 nodes (210 simplex iterations) in 0.01 seconds (0.01 work units)
Thread count was 16 (of 16 available processors)
Solution count 2: 41.8181 79.9211
Optimal solution found (tolerance 1.00e-04)
Best objective 4.181805855720e+01, best bound 4.181805855720e+01, gap 0.0000%
#+end_example

#+begin_src python
for ((letter, key), assigned) in keys_to_letters.items():
    if assigned.x == 1:
        print(f'{letter} is assigned to key {key}')
#+END_SRC

#+RESULTS:
#+begin_example
A is assigned to key 11
B is assigned to key 13
C is assigned to key 6
D is assigned to key 0
E is assigned to key 1
F is assigned to key 9
G is assigned to key 15
H is assigned to key 8
I is assigned to key 22
J is assigned to key 23
K is assigned to key 16
L is assigned to key 3
M is assigned to key 17
N is assigned to key 10
O is assigned to key 18
P is assigned to key 25
Q is assigned to key 14
R is assigned to key 2
S is assigned to key 5
T is assigned to key 12
U is assigned to key 20
V is assigned to key 24
W is assigned to key 21
X is assigned to key 7
Y is assigned to key 19
Z is assigned to key 4
#+end_example

* DONE generalized graph matching
CLOSED: [2025-02-20 Thu 22:15]

#+begin_src python
@dataclass
class KeyboardLayout:
    key_assignments: List[str]

    def assigned_letter(self, key):
        return self.key_assignments[letter]

    def assigned_key(self, letter):
        return self.key_assignments.index(letter)
#+end_src

#+RESULTS:

#+begin_src python
def find_optimal_layout(letter_weights, key_costs):
    m = gp.Model()
    keys_to_letters = m.addVars(letters, keys, vtype=gp.GRB.BINARY)

    m.addConstrs(
        (
            sum(keys_to_letters[letter, key] for key in keys) == 1
                for letter in letters
        ),
        name='each letter assigned once'
    )

    m.addConstrs(
        (
            sum(keys_to_letters[letter, key] for letter in letters) == 1
            for key in keys
        ),
        name='each key assigned once'
    )

    def key_letter_weight(letter, key):
        return letter_weights[letter] * key_costs[key]

    m.setObjective(
        sum(
            key_letter_weight(letter, key) * keys_to_letters[letter, key]
            for letter in letters
            for key in keys
        ),
        sense=gp.GRB.MINIMIZE
    )

    m.optimize()

    key_assignments = [None for _ in range(len(key_costs))]
    for ((letter, key), assigned) in keys_to_letters.items():
        if assigned.x == 1:
            key_assignments[key] = letter

    return KeyboardLayout(key_assignments)
#+end_src

#+RESULTS:

#+begin_src python
letter_weights = {
  letter: letter_frequencies.loc[[letter]].texts.iloc[0]
  for letter in letters
}
keyboard_layout = find_optimal_layout(letter_weights, key_costs)
print(keyboard_layout)
#+end_src

#+RESULTS:
#+begin_example
Gurobi Optimizer version 11.0.3 build v11.0.3rc0 (linux64 - "NixOS 25.05 (Warbler)")
CPU model: AMD Ryzen 7 7840U w/ Radeon  780M Graphics, instruction set [SSE2\AVX\AVX2\AVX512]
Thread count: 8 physical cores, 16 logical processors, using up to 16 threads
Optimize a model with 52 rows, 676 columns and 1352 nonzeros
Model fingerprint: 0xbda6a150
Variable types: 0 continuous, 676 integer (676 binary)
Coefficient statistics:
Matrix range     [1e+00, 1e+00]
Objective range  [2e-03, 2e+01]
Bounds range     [1e+00, 1e+00]
RHS range        [1e+00, 1e+00]
Found heuristic solution: objective 79.9210606
Presolve time: 0.00s
Presolved: 52 rows, 676 columns, 1352 nonzeros
Variable types: 0 continuous, 676 integer (676 binary)
Root relaxation: objective 4.181806e+01, 210 iterations, 0.00 seconds (0.00 work units)
Nodes    \    Current Node    \     Objective Bounds      \     Work
Expl Unexpl \  Obj  Depth IntInf \ Incumbent    BestBd   Gap \ It/Node Time
,*    0     0               0      41.8180586   41.81806  0.00%     -    0s
Explored 1 nodes (210 simplex iterations) in 0.00 seconds (0.01 work units)
Thread count was 16 (of 16 available processors)
Solution count 2: 41.8181 79.9211
Optimal solution found (tolerance 1.00e-04)
Best objective 4.181805855720e+01, best bound 4.181805855720e+01, gap 0.0000%
KeyboardLayout(key_assignments=['D', 'E', 'R', 'L', 'Z', 'S', 'C', 'X', 'H', 'F', 'N', 'A', 'T', 'B', 'Q', 'G', 'K', 'M', 'O', 'Y', 'U', 'W', 'I', 'J', 'V', 'P'])
#+end_example

* TODO add digrams and trigrams
** scratch

#+begin_src python

#+end_src

* TODO mismatched lengths of keys and positions
* TODO real bipartite graph matching, with real keys and real costs
